import sys
import time

import argparse
import mido
from mido import MidiFile
from mido import Message
import pathlib
import time

parser = argparse.ArgumentParser()
parser.add_argument('path', type=pathlib.Path, help = "path to midi file")
args = parser.parse_args()

filename = sys.argv[1]
notes = []
test = []

#######################################

try:
    for msg in MidiFile(args.path):
        if msg.time < 0.02 or msg.time > 15000:
            continue
        if msg.dict()["type"] == "end_of_track":
            break
            
        notes.append((msg.note, round(msg.time*1000)))
        test.append(msg.note)

except KeyboardInterrupt:
    output.reset()

#######################################

output_str = f'''
// autogenerated by midi_to_beeps script

pub const FREQ_LIST: [u16; 128]=
[''' 

for i in range(128):
    if i % 12 == 0:
        output_str = output_str + "\n    "

    freq = 440 * 2**((i-69)/12)
    output_str = output_str + f"{round(freq)}, "
output_str = output_str[:-2] + "\n];\n\n"


output_str = output_str + f"pub const NOTES_LIST: [(u8, u16); {len(notes)}] = \n[\n"
for (i, note) in enumerate(notes):
    if i % 12 == 0:
        output_str = output_str + "\n    "

    output_str = output_str + f"({note[0]}, {note[1]}), "
output_str = output_str + "\n];\n"

# print(output_str)
print("writing to file...")
with open('beeps.txt', 'w') as file:
    file.write(output_str)
print("written to file 'beeps.txt'")