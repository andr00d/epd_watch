import argparse
import numpy as np
import pathlib
import os
import sys
import cv2
import matplotlib
import matplotlib.pyplot as plt
import triangle as tr
import time
#######################################

parser = argparse.ArgumentParser()
parser.add_argument('path', type=pathlib.Path, help = "path to video file ")
parser.add_argument("-f", "--framerate", type=int, default=3, help = "framerate of output (2-3 is recommended)")
parser.add_argument("--framecount", type=int, default=3, help = "max number of frames to generate")
args = parser.parse_args()

if args.framerate < 1 or args.framerate > 60:
    print(f"invalid framerate provided. ({args.framerate})")
    exit()

if args.framecount < 1 or args.framecount > 1000:
    print(f"invalid framecount provided. ({args.framerate})")
    exit()

aprox_lvl = 3
min_pixels = 5

#######################################

def get_testpoint(cntr, cntr_i, i, contours, img):
    # offsets = [(x, y) for x in [-2, 2] for y in [-2, 2] if not (x == 0 and y == 0)]
    offsets = [(x, y) for x in [-6, -3, 0, 3, 6] for y in [-6, -3, 0, 3, 6] if not (x == 0 and y == 0)]
    vertices = [(int(v.flatten()[0]), int(v.flatten()[1])) for v in cntr]

    # get all other valid contours
    other_cntrs = [cv2.approxPolyDP(cnt,aprox_lvl,True) for (cnt_i, cnt) in enumerate(contours) if not cnt_i == cntr_i]
    other_cntrs = [cnt for cnt in other_cntrs if max([x[0][0] for x in cnt]) - min([x[0][0] for x in cnt]) >= min_pixels]
    other_cntrs = [cnt for cnt in other_cntrs if max([x[0][1] for x in cnt]) - min([x[0][1] for x in cnt]) >= min_pixels]

    # get nested contours
    inner_cntrs = []
    for cnt in other_cntrs:
        vnt_verts = [(int(v.flatten()[0]), int(v.flatten()[1])) for v in cnt]
        mean_pointval = np.array([cv2.pointPolygonTest(cntr, val, True) for val in vnt_verts]).mean()
        if mean_pointval < 0:
            inner_cntrs.append(cnt)

    # create all valid testpoints
    test_points = [(v[0] + offset[0], v[1] + offset[1]) for v in vertices for offset in offsets]
    dists = [cv2.pointPolygonTest(cntr, p, True) for p in test_points]
    min_dist = dists.index(max(dists))

    return test_points[min_dist]


#######################################

vert_list = []
tri_list = []

cap = cv2.VideoCapture(args.path)
frame_skip = max(int(cap.get(cv2.CAP_PROP_FPS) / args.framerate), 1)

if not cap.isOpened():
    print(f"error opening file ({args.path})")
    exit()

for i in range(args.framecount):
    print(f"working on frame {i}")
    ret, img = cap.read()
    
    if not ret:
        print(f"error reading frame {i}")
        break
    
    min_side = min(img.shape[0], img.shape[1])
    w_offset = int((img.shape[0]-min_side) / 2)
    h_offset = int((img.shape[1]-min_side) / 2)
    img = img[w_offset:img.shape[0]-w_offset, h_offset:img.shape[1]-h_offset]
    img = cv2.resize(img, (200, 200), interpolation= cv2.INTER_LINEAR)

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret,thresh = cv2.threshold(gray,127,255,cv2.THRESH_BINARY_INV)
    frame_verts = []
    frame_tris = []

    #######################################

    contours,hierarchy = cv2.findContours(thresh, cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    pts = []
    seg = []
    holes = []

    for (cnt_i, cnt) in enumerate(contours): 

        approx = cv2.approxPolyDP(cnt,aprox_lvl,True)
        w = max([x[0][0] for x in approx]) - min([x[0][0] for x in approx])
        h = max([x[0][1] for x in approx]) - min([x[0][1] for x in approx])
        if w <= min_pixels or h <= min_pixels or len(approx) < 3:
            continue

        test_point = get_testpoint(approx, cnt_i, i, contours, img)
        img = cv2.circle(img, test_point, 1, (255, 0, 0), 1) 
        color = thresh[test_point[1], test_point[0]]
        offset = len(pts)

        if color == 0:
            holes.append(test_point)

        for j, pnt in enumerate(approx):
            img = cv2.circle(img, (int(pnt[0][0]), int(pnt[0][1])), 1, (0, 0, 255), 1) 
            pts.append(pnt[0])
            seg.append([offset + j, offset + (j+1)%len(approx)])

    if len(holes) == 0:
            holes.append([-1,-1])
    if len(pts) < 3:
        vert_list.append([])
        tri_list.append([])
        continue

    tri_input = dict(vertices=pts, segments=seg, holes=holes)
    tri_output = tr.triangulate(tri_input,'p')
    # tr.compare(plt, tri_input, tri_output)
    # plt.savefig("test/{:03d}.png".format(i))
    
    vert_list.append(tri_output["vertices"])
    tri_list.append(tri_output["triangles"])
    

    # lower framerate
    for _ in range(frame_skip-1):
        ret, _ = cap.read()

        if not ret:
            print(f"error reading frame")
            break

#######################################

vert_len = sum([len(lst) + 1 for lst in vert_list])
tri_len  = sum([len(lst) + 1 for lst in tri_list])

output_str = f'''
// autogenerated by frame_gen script

// first value is the number of tris in this frame
pub const VID_TRIS: [(u8, u8, u8); {tri_len}]=
[
'''

for f_tri in tri_list:
    output_str = output_str + f"    ({len(f_tri)}, {len(f_tri)}, {len(f_tri)}), "

    for tri in f_tri:
        output_str = output_str + f"({int(tri[0])}, {int(tri[1])}, {int(tri[2])}), "
    output_str = output_str + "\n"

output_str = output_str + "];\n\n// first value is the number of verts in this frame\n"
output_str = output_str + f"pub const VID_VERTS: [(u8, u8); {vert_len}] = \n[\n"

for f_vert in vert_list:
    output_str = output_str + f"    ({len(f_vert)}, {len(f_vert)}), "

    for vert in f_vert:
        output_str = output_str + f"({int(vert[0])}, {int(vert[1])}), "
    output_str = output_str + "\n"
output_str = output_str + "];\n"

print("writing to file...")
with open('frames.txt', 'w') as file:
    file.write(output_str)
print("written to file 'frames.txt'")