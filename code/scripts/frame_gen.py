import argparse
import numpy as np
import pathlib
import os
import sys
import cv2
import matplotlib
import matplotlib.pyplot as plt
import triangle as tr
#######################################

parser = argparse.ArgumentParser()
parser.add_argument('path', type=pathlib.Path, help = "path to video file ")
parser.add_argument("-f", "--framerate", type=int, default=3, help = "framerate of output (2-3 is recommended)")
parser.add_argument("--framecount", type=int, default=3, help = "max number of frames to generate")
args = parser.parse_args()

if args.framerate < 1 or args.framerate > 60:
    print(f"invalid framerate provided. ({args.framerate})")
    exit()

if args.framecount < 1 or args.framecount > 500:
    print(f"invalid framecount provided. ({args.framerate})")
    exit()

#######################################

vert_list = []
tri_list = []

cap = cv2.VideoCapture(args.path)
frame_skip = max(int(cap.get(cv2.CAP_PROP_FPS) / args.framerate), 1)

if not cap.isOpened():
    print(f"error opening file ({args.path})")
    exit()

# for _ in range(120):
#     ret, img = cap.read()

for i in range(args.framecount):
    print(f"working on frame {i}")
    ret, img = cap.read()
    
    if not ret:
        print(f"error reading frame {i}")
        break
    
    min_side = min(img.shape[0], img.shape[1])
    w_offset = int((img.shape[0]-min_side) / 2)
    h_offset = int((img.shape[1]-min_side) / 2)
    img = img[w_offset:img.shape[0]-w_offset, h_offset:img.shape[1]-h_offset]
    img = cv2.resize(img, (200, 200), interpolation= cv2.INTER_LINEAR)

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret,thresh = cv2.threshold(gray,127,255,cv2.THRESH_BINARY_INV)
    frame_verts = []
    frame_tris = []

    #######################################

    contours,hierarchy = cv2.findContours(thresh, cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    pts = []
    seg = []
    holes = []

    for cnt in contours: 

        approx = cv2.approxPolyDP(cnt,2,True)
        w = max([x[0][0] for x in approx]) - min([x[0][0] for x in approx])
        h = max([x[0][1] for x in approx]) - min([x[0][1] for x in approx])
        if w <= 5 or h <= 5:
            continue

        # test point currently at center, can fuck up with certain concave shapes, but too lazy to fix for a meme.
        test_point = np.array(approx).mean(axis=0)
        img = cv2.circle(img, (int(test_point[0][0]), int(test_point[0][1])), 1, (255, 0, 0), 1) 
        color = thresh[int(test_point[0][1]), int(test_point[0][0])]
        offset = len(pts)

        if color == 0:
            holes.append(test_point[0])

        for i, pnt in enumerate(approx):
            img = cv2.circle(img, (int(pnt[0][0]), int(pnt[0][1])), 1, (0, 0, 255), 1) 
            pts.append(pnt[0])
            seg.append([offset + i, offset + (i+1)%len(approx)])

    if len(holes) == 0:
        holes.append([0,0])

    tri_input = dict(vertices=pts, segments=seg, holes=holes)
    tri_output = tr.triangulate(tri_input,'p')

    vert_list.append(tri_output["vertices"])
    tri_list.append(tri_output["triangles"])
    

    # lower framerate
    for _ in range(frame_skip-1):
        ret, _ = cap.read()

        if not ret:
            print(f"error reading frame")
            break

#######################################

vert_len = sum([len(lst) + 1 for lst in vert_list])
tri_len  = sum([len(lst) + 1 for lst in tri_list])

output_str = f'''
// autogenerated by frame_gen script

// first value is the number of tris in this frame
pub const VID_TRIS: [(u8, u8, u8); {tri_len}]=
[
'''

for f_tri in tri_list:
    output_str = output_str + f"    ({len(f_tri)}, {len(f_tri)}, {len(f_tri)}), "

    for tri in f_tri:
        output_str = output_str + f"({int(tri[0])}, {int(tri[1])}, {int(tri[2])}), "
    output_str = output_str + "\n"

output_str = output_str + "];\n\n// first value is the number of verts in this frame\n"
output_str = output_str + f"pub const VID_VERTS: [(u8, u8); {vert_len}] = \n[\n"

for f_vert in vert_list:
    output_str = output_str + f"    ({len(f_vert)}, {len(f_vert)}), "

    for vert in f_vert:
        output_str = output_str + f"({int(vert[0])}, {int(vert[1])}), "
    output_str = output_str + "\n"
output_str = output_str + "];\n"

print("writing to file...")
with open('frames.txt', 'w') as file:
    file.write(output_str)
print("written to file 'frames.txt'")